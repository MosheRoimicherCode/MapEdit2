<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
    <meta charset="utf-8">
    <title>split tool</title>
    <meta http-equiv="X-UA-Compatible" content="IE=11">
    <link rel="StyleSheet" href="Style.css" type="text/css">

</head>

<body id="Body" >

    <h3>Terrain Modification with File Upload</h3>
    <p>Effortlessly create terrain modifications by uploading a KML file.</p>
    <table>
        <td>
            <div style="display: none;">
                &nbsp;<input id="file" class="file" type="file" value="3" size="5" accept=".kml , .kmz"
                    onchange="document.all['fileText'].value=this.value;" />
            </div>
            <div id="filediv">
                &nbsp;<input id="fileText" type="text" value="" size="2"/>
                <img style="cursor:pointer" src="img/Browse.png" onclick="document.all['file'].click();" alt="File" />
            </div>
        </td>
    </table>
    
    <button id="add" onclick="AddEvent()">Add Event</button>
    <button id="remove" onclick="RemoveEvent()">Remove Event</button>

    <p>Note: Your KML file should contain a single polygon geometry.</p>



    <script language="javascript" src="./jquery/jquery-3.1.1.min.js"></script>
    <script language="javascript" src="./getSGWorld.js"></script>
    <script language="javascript" src="./ToolsCommon73.js"></script>
    <img class="logo" src="./KavLogo.png" alt="Logo" height="65px" width="auto" />


    <script language="JavaScript">

        var SGWorld = initSGWorld("");
        var selectedObject;
        var SplitPosition;

        
        // SGWorld.AttachEvent("OnSGWorld", OnSGWorld)

        function OnSGWorld(EventID,EventParam){
            alert("EventId fo OnSGWolrd Event: " + EventID)
        }


        function GetObjectVertexes(object){
            var points = convertGeometryPointsToArray(object)
            //alert(points[0].x)
            return points
        }


        function GetItemName(Id){
            return SGWorld.ProjectTree.GetItemName(Id);
        }
        
        function SplitLine(){
            //alert(1)
            try{
            //SGWorld.AttachEvent("OnLButtonDown", GetClickPosition);
            AddEvent()
            //SGWorld.Command.Execute("1021","")


            RemoveEvent()	
            }
            catch (error){
                console.error(error);
                alert(error)
            }

        }

        function GetClickPosition(X,Y,Flags){
            
        }

        function OnObjectSelected(ObjectID){
            try{
            var Object = SGWorld.ProjectTree.GetObject(ObjectID);
            var ObjectName = SGWorld.ProjectTree.GetItemName(ObjectID);
            
            //To Do: Convert object to absolute, and then return to original position, or in the mouse altititude, get the same altitude type as the line

            //var objectHeight = SGWorld.Terrain.GetGroundHeightInfo(X, Y, 2, true);

            //1. get the ground object state of object
            //groungObjectOriginalState = Object.Terrain.GroundObject;
            //2. set the curret stae to "true"
            //Object.Terrain.GroundObject = true
            //3. get the mouse position (ground info mybe)
            mousePosition = SGWorld.Window.GetMouseInfo()
            mouseGeoPoition = SGWorld.Window.PixelToWorld(mousePosition.X, mousePosition.Y).Position

            //4. return the ground state to original
             //Object.Terrain.GroundObject = groungObjectOriginalState

            //5.with the position, calculate the segmnet part

            

            //alert(Object.Geometry.GeometryTypeStr);
            var points =  GetObjectVertexes(Object)

            console.log("amount of feature vertexes= =" + points.length)

            target = { x: mouseGeoPoition.X, y:  mouseGeoPoition.Y, z: mouseGeoPoition.Altitude};
            console.log(target.x)
            console.log(target.y)
            console.log(target.z)

            //findTwoClosestPoints(target,points)
            var previusVertex = findSegmentForPoint(points, target) //the click its located between the index and the index+1 vertex
            console.log("vertex index =" + previusVertex)

            var result = splitArrayAtIndex(points, previusVertex, target);

            SGWorld.Creator.CreatePolylineFromArray(result[0], "#158895",3)
            SGWorld.Creator.CreatePolylineFromArray(result[1], "#157775",3)

            RemoveEvent()
            }
            catch (error){
                console.error(error);
                alert(error)
            }
        }

        function AddEvent(){
            SGWorld.AttachEvent("OnObjectSelected", OnObjectSelected);
            //SGWorld.AttachEvent("On")
            SGWorld.Command.Execute("1021","")
        }

        function RemoveEvent(){
            SGWorld.DetachEvent("OnObjectSelected", OnObjectSelected);
        }

        function convertGeometryPointsToArray(object) {
            var points = [];
            var geometryPoints = object.Geometry.Points;
            var count = geometryPoints.Count;

            for (var i = 0; i < count; i++) {
                var pt = geometryPoints.Item(i);
                points.push({
                    x: pt.X,
                    y: pt.Y,
                    z: pt.Z
                });
            }

            return points;
        }

        function splitArrayAtIndex(vertices, index, newPoint) {
            // Ensure the index is within the bounds of the array
            if (index < 0 || index >= vertices.length) {
                console.error("Index is out of bounds");
                return null;
            }

            // Split the array into two parts
            const firstArray = vertices.slice(0, index + 1);  // From 0 to index
            const secondArray = vertices.slice(index + 1);   // From index + 1 to end

            // Function to convert array of vertices to [x, y, z, x, y, z, ...] format
            var convertToXYZArray = function(arr) {
                var result = [];
                for (var i = 0; i < arr.length; i++) {
                    result = result.concat([arr[i].x, arr[i].y, arr[i].z]);
                }
                return result;
            };

            // Convert both arrays to the desired format
            var firstArrayXYZ = convertToXYZArray(firstArray);
            var secondArrayXYZ = convertToXYZArray(secondArray);



            if (newPoint) {
                firstArrayXYZ.push(newPoint.x, newPoint.y, newPoint.z);  // Adds to the last position of the first array
                secondArrayXYZ.unshift(newPoint.x, newPoint.y, newPoint.z);  // Adds to the first position of the second array
            }

            //return [ new VBArray(firstArrayXYZ), new VBArray(secondArrayXYZ) ];
            return [ firstArrayXYZ, secondArrayXYZ];
        }




        function findSegmentForPoint(lineVertices, point) {
            //alert("findSegmentForPoint")
            var tolerance = SGWorld.Navigate.GetPosition(3).Altitude
            for (let i = 0; i < lineVertices.length - 1; i++) {
                const p1 = lineVertices[i];
                const p2 = lineVertices[i + 1];

                // Check if the point lies between p1 and p2 on the segment
                if (isPointOnSegment(p1, p2, point.x, point.y, point.z, tolerance)) {
                    //alert(i + " - " + (i + 1));  // Alert showing the segment's indices
                    return i; // Return the index of the segment (between p1 and p2)
                }
            }
            alert("No segment found")
            return -1; // Return -1 if the point is not on any segment (error case)
        }

        // Function to check if the point lies on the segment defined by p1 and p2
        function isPointOnSegment(p1, p2, px, py, pz, tolerance) {
            // Calculate the segment vector and point vector
            var segmentVector = { x: p2.x - p1.x, y: p2.y - p1.y, z: p2.z - p1.z };
            var pointVector = { x: px - p1.x, y: py - p1.y, z: pz - p1.z };

            // Cross product of segment and point vector should be close to zero if the point is on the line
            var crossProduct = {
                x: segmentVector.y * pointVector.z - segmentVector.z * pointVector.y,
                y: segmentVector.z * pointVector.x - segmentVector.x * pointVector.z,
                z: segmentVector.x * pointVector.y - segmentVector.y * pointVector.x
            };

            // If the cross product is not nearly zero, the point is not on the line
            var crossProductLength = Math.sqrt(Math.pow(crossProduct.x, 2) + Math.pow(crossProduct.y, 2) + Math.pow(crossProduct.z, 2));
            if (crossProductLength > tolerance) {
                return false;
            }
            // Check if the point is within the bounds of the segment
            var dotProduct = segmentVector.x * pointVector.x + segmentVector.y * pointVector.y + segmentVector.z * pointVector.z;
            var segmentLengthSquared = Math.pow(segmentVector.x, 2) + Math.pow(segmentVector.y, 2) + Math.pow(segmentVector.z, 2);

            // If the dot product is between 0 and the segment length squared, the point is on the segment
            return dotProduct >= 0 && dotProduct <= segmentLengthSquared;
        }
    </script>

</body>

</html>
